/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable @typescript-eslint/no-empty-function */

const sass = require("sass");
const path = require("path");
const fs = require("fs");
const postCssLoader = require("postcss-loader");

const logger = console;
logger.verbose = process.env.LOG_VERBOSE === "1" ? logger.info : () => {};

/** Invoke async postcss through Webpack5 loader to process with all plugins */
const invokePostCssLoader = (src) => {
  let error = undefined;
  return new Promise((resolve, reject) => {
    postCssLoader
      .apply(
        {
          emitWarning: (...args) => logger.warn("Warning", ...args),
          emitError: (err) => {
            logger.error("Error", err);
            error = err
          },
          resourcePath: __dirname,
          fs,
          addDependency: (name) => {
            logger.verbose("Add dependency", name);
          },
          addContextDependency: (name) => {
            logger.verbose("Add context dependency", name);
          },
          addBuildDependency: (file) => {
            logger.verbose("Add build dependency", file);
          },
          getOptions: () => ({}),
          query: "?",
          async: () => {
            return (err, css) => resolve([err || error, css]);
          },
        },
        [src]
      )
      .catch((err) => reject(err));
  });
};

/**
 * Generates styled components component with global styles for the extension.
 * One notable issue is that imports cannot be used and need to be repeated by JS code manually.
 */

const renderOne = async (scss, componentFile, componentName) => {
  const result = sass.renderSync({
    file: scss,
  });

  const root = path.resolve(__dirname, "..");
  const relSource = path.relative(root, scss);

  const relComponentFile = path.relative(root, componentFile);
  const prePostcss = result.css.toString().replace(/(\@tailwind ([a-zA-Z_0-9]+))/g, (_match, _full, name) =>
       `/*! === Tailwind layer ${name} === */
@tailwind ${name};
/*! === Tailwind layer ${name} end === */
`
  );
  const [error, intermediary] = await invokePostCssLoader(prePostcss);
  if (error) {
    throw error
  }
  const css = intermediary
    // Move under component generated name
    .replace(":root {", "& {")
    // Move under component generated name
    .replace(".sb-show-main {", ".sb-show-main, & {")
    // Proper accessor for fonts
    .replace(/require\(\"(.*?)\"\)/g, '${require("$1?raw")}')
    // Replace some wrong comments: because of error messages generated by ts-styled-plugin 9999
    .replace(/\`sans\`/g, "sans")
    .replace(/\`em\`/g, "em")
    .replace(/\`:invalid\`/g, ":invalid")
    .replace(/\`mono\`/g, "mono")
    .replace(/\`inherit\`/g, "inherit")
    .replace(/\`sub\`/g, "sub")
    .replace(/\`sup\`/g, "sup")
    .replace(/\`display: block\`/g, "display: block")
    .replace(/\`vertical-align: middle\`/g, "vertical-align: middle")
    .replace(/\`html\`/g, "html");

  const componentCode = `// prettier-ignore
// eslint-disable
import styled from "styled-components";
import React from "react";

// Autogenerated, do not edit! Created automatically from ${relSource}
const ${componentName}Css = styled.div\`
${css
  .split("\n")
  .map((l) => (l.trim() != "" ? "  " + l : ""))
  .join("\n")}
\`;

export const ${componentName} = ({
  children
}: {
  children: React.ReactNode;
}) => (
    <${componentName}Css className="globalStyle">{children}</${componentName}Css>
  );
`;

  const existing = fs.existsSync(componentFile) ? fs.readFileSync(componentFile, { encoding: "utf-8" }) : "";

  if (existing != componentCode) {
    logger.info("Writing", relComponentFile, "from", relSource);
    fs.writeFileSync(componentFile, componentCode);
  }
};

/**
 * Writes global css as styled component so it can be consumed
 * inside augmented mail where we cant and wont style entire app.
 */
const renderComponents = async (webpackContext) => {
  try {
    const src = path.resolve("src/global.css");
    if (webpackContext) {
      webpackContext.addDependency(src);
    }
    return renderOne(src, path.resolve("src/GlobalStyle.tsx"), "GlobalStyle");
  } catch (e) {
    logger.warn(e);
    return false;
  }
};

/**
 * Plugs into the Webpack to recreate before compilation, if needed.
 *
 * See more here: https://webpack.js.org/api/compiler-hooks/
 */
class WebpackPlugin {
  apply(compiler) {
    if (compiler.hooks?.afterCompile) {
      compiler.hooks.afterCompile.tap("GenerateStyledCssPlugin", (compilation) => {
        logger.verbose("Adding dependencies", this.dependencies);
        this.dependencies.forEach((file) => compilation.fileDependencies.add(file));
      });
    }

    if (compiler.hooks && compiler.hooks.beforeCompile) {
      compiler.hooks.beforeCompile.tapAsync("GenerateStyledCssPlugin", (_context, callback) => {
        this.dependencies = [];
        renderComponents({
          addDependency: (file) => this.dependencies.push(file),
        })
          // eslint-disable-next-line promise/no-callback-in-promise
          .then((_) => callback())
          .catch((err) => {
            logger.warn("Failed to process", err);
          });
      });
    } else {
      logger.warn("Cannot find compiler.hooks.beforeRun hook");
    }
  }
}

if (require.main === module) {
  renderComponents();
}

module.exports = {
  renderComponents,
  renderOne,
  WebpackPlugin,
};
